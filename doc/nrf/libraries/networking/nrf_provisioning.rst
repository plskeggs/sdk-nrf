.. _lib_nrf_provisioning:

nRF Device provisioning
#######################

.. contents::
   :local:
   :depth: 2

The nRF Device provisioning library enables a device to connect to Nordic Semiconductor's provisioning Service.
It abstracts and hides the details of the transport and the encoding scheme that is used for the payload.
The current implementation supports the following technologies:

* AT-command based provisioning commands
* Writing key-value pair based settings to the :ref:`settings_api` storage
* TLS secured HTTP as the communication protocol
* Client authentication with Attestation Token
* Client authentication with JWT token
* CBOR as the data format

Configuration
*************

To enable the library, set the :kconfig:option:`CONFIG_NRF_PROVISIONING` Kconfig option to ``y``.

Configuration options for transport protocol
============================================

For now, HTTP is the only supported transport protocol.

* :kconfig:option:`CONFIG_NRF_PROVISIONING_SYS_INIT` - Initializes the client in the system initialization phase
* :kconfig:option:`CONFIG_NRF_PROVISIONING_ROOT_CA_SEC_TAG` - Root CA security tag for the provisioning Service
* :kconfig:option:`CONFIG_NRF_PROVISIONING_HTTP_HOSTNAME` - HTTP API hostname for the provisioning Service
* :kconfig:option:`CONFIG_NRF_PROVISIONING_HTTP_PORT` - Port number for the provisioning Service
* :kconfig:option:`CONFIG_NRF_PROVISIONING_HTTP_TIMEOUT_MS` - Timeout in milliseconds for HTTP connection of the provisioning Service
* :kconfig:option:`CONFIG_NRF_PROVISIONING_HTTP_RX_BUF_SZ` - HTTP response payload buffer size
* :kconfig:option:`CONFIG_NRF_PROVISIONING_HTTP_TX_BUF_SZ` - HTTP request body size
* :kconfig:option:`CONFIG_NRF_PROVISIONING_HTTP_JWT` - Chooses JWT token for client authentication
* :kconfig:option:`CONFIG_NRF_PROVISIONING_HTTP_ATTESTTOKEN` - Chooses attestation token for client authentication

.. _lib_nrf_provisioning_start:

Usage
*****

The usage of the nRF Device provisioning library is described in the following sections.

Initialization
==============

Once initialized, the provisioning client will run on its own in the background.
The provisioning client can be initialized in following two ways:

* The application calls :c:func:`nrf_provisioning_init` which starts the client.
* Set the client to initialize during Zephyr's system initialization phase.
  In this case it is assumed that a network connection has been established in the same phase.

The function uses the following two arguments:

*  A pointer to a callback function which is to be called on modem state changes.
*  A pointer that must be called once provisioning is done.

If you provide ``null`` as a callback function address argument, a corresponding default callback used.
Consequent calls to the initialization function will only change the callback functions.
This behavior is beneficial when the client has been initialized during the system initialization phase, but the application wants to register its own callback functions afterwards.

Provisioning
============

By default, when provisioning is done after receiving the ``FINISHED`` command, the device is rebooted.
The behavior can be overwritten by providing a unique callback function for the initialization function.

If anything is written on the modem's non-volatile memory, the modem needs to be set in offline mode.
This is because the modem cannot be connected when any data is to be written on to its storage area.
After the memory write is completed, the aforementioned callback function must be called again to set the modem in desired state.
To use the default implementation, ``NULL`` can be passed as an argument to the :c:func:`nrf_provisioning_init` function.
The default callback function must be copied and modified based on your needs if it is necessary.

The library starts provisioning when it initializes and afterwards it is done in a configured interval.
The interval is read from the storage settings, and it can be updated with a provisioning command like any other key-value pair.

During provisioning, the library first tries to establish the transport for communicating with the service.
This procedure involves a TLS handshake where the client establishes the correct server.
The server uses the attestation token or the JWT token generated by the device for authenticating the client.
See :ref:`lib_modem_attest_token` and :ref:`lib_modem_jwt` for more information on client authentication.

The TLS handshake needs to be done twice:

* Before requesting commands
* After the execution of the commands to report the results.

The library shuts down the modem for writing data to the modem's non-volatile memory, if `AT commands <AT Commands Reference Guide_>`_ are involved.
Once the memory writes are complete, connection is re-established to report the results back to the server.
The results are reported back to the server when either all the commands succeed or when an error occurs.
If an error occurs, the results of all the commands that are successfully executed before the error and the erroneous result are reported back to the server.
All successfully executed commands will be removed from the server-side queue, but if any errors occur, the erroneous command and all the remaining unexecuted commands will be flushed from the queue.
You will be notified on the log about the issue.

An immediate provisioning can be requested by calling the :c:func:`nrf_provisioning_trigger_manually` function.
Otherwise, the library provision according to the set interval.
To trigger immediate provisioning, the library must be initialized first.

The following message sequence chart shows a successful provisioning sequence:

.. msc::
   hscale = "1.1";
   Owner,Server,Device;
   Owner>>Server     [label="Provision: cmd1, cmd2, finished"];
   Server<<Device    [label="Get commands"];
   Server>>Device    [label="Return commands"];
   Device box Device [label="Decode commands"];
   Device box Device [label="Put modem offline"];
   Device box Device [label="Write to non-volatile memory"];
   Device box Device [label="Restore modem state"];
   Server<<Device    [label="cmd1,cmd2, finished succeeded"];

The following message sequence chart shows a failing provisioning sequence:

.. msc::
   hscale = "1.3";
   Owner,Server,Device;
   Owner>>Server     [label="Provision: cmd1, cmd2, cmd3, finished"];
   Server<<Device    [label="Get commands"];
   Server>>Device    [label="Return commands"];
   Device box Device [label="Decode commands"];
   Device box Device [label="Put modem offline"];
   Device box Device [label="cmd1: Write to non-volatile memory"];
   Device box Device [label="cmd2: Fails"];
   Device box Device [label="Restore modem state"];
   Server<<Device    [label="cmd1 success, cmd2 failed"];
   Server>>Server    [label="Empty the command queue"];
   Server>>Owner     [label="cmd2 failed"];

.. _nrf_provisioning_shell:

nRF Provisioning shell
**********************

For testing the client, it is possible to enable Zephyr's shell and provisioning command, which makes it possible to control the client over UART.
Currently, only the supported subcommand makes it possible to trigger provisioning immediately.
The feature is enabled by selecting :kconfig:option:`CONFIG_NRF_PROVISIONING_SHELL`.
The shell is meant for testing so production systems must not enable it.

.. code-block:: console

   uart:~$ nrf_provisioning
   nrf_provisioning - nRF Provisioning commands
   Subcommands:
   now  :Do provisioning now

.. _nrf_provisioning_api:

API documentation
*****************

| Header file: :file:`include/net/nrf_provisioning.h`
| Source files: :file:`subsys/net/lib/nrf_provisioning/src/`

.. doxygengroup:: nrf_provisioning
   :project: nrf
   :members:
